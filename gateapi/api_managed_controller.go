
/*
 * Spinnaker API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ManagedControllerApiService service

/* 
ManagedControllerApiService Create a pin for an artifact in an environment
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param pin pin


*/
func (a *ManagedControllerApiService) CreatePinUsingPOST(ctx context.Context, application string, pin EnvironmentArtifactPin) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/pin"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &pin
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Delete a delivery config manifest for an application
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application

@return DeliveryConfig
*/
func (a *ManagedControllerApiService) DeleteManifestByAppUsingDELETE(ctx context.Context, application string) (DeliveryConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeliveryConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DeliveryConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Delete a delivery config manifest
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name

@return DeliveryConfig
*/
func (a *ManagedControllerApiService) DeleteManifestUsingDELETE(ctx context.Context, name string) (DeliveryConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeliveryConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/delivery-configs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DeliveryConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Unpin one or more artifact(s) in an environment. If the &#x60;reference&#x60; parameter is specified, only the corresponding artifact will be unpinned. If it&#39;s omitted, all pinned artifacts in the environment will be unpinned.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param targetEnvironment targetEnvironment
 * @param optional nil or *ManagedControllerApiDeletePinUsingDELETEOpts - Optional Parameters:
     * @param "Reference" (optional.String) -  reference


*/

type ManagedControllerApiDeletePinUsingDELETEOpts struct { 
	Reference optional.String
}

func (a *ManagedControllerApiService) DeletePinUsingDELETE(ctx context.Context, application string, targetEnvironment string, localVarOptionals *ManagedControllerApiDeletePinUsingDELETEOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/pin/{targetEnvironment}"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"targetEnvironment"+"}", fmt.Sprintf("%v", targetEnvironment), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Reference.IsSet() {
		localVarQueryParams.Add("reference", parameterToString(localVarOptionals.Reference.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Remove veto of an artifact version in an environment
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param reference reference
 * @param targetEnvironment targetEnvironment
 * @param version version


*/
func (a *ManagedControllerApiService) DeleteVetoUsingDELETE(ctx context.Context, application string, reference string, targetEnvironment string, version string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/veto/{targetEnvironment}/{reference}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reference"+"}", fmt.Sprintf("%v", reference), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"targetEnvironment"+"}", fmt.Sprintf("%v", targetEnvironment), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", fmt.Sprintf("%v", version), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Ad-hoc validate and diff a config manifest
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param manifest manifest

@return interface{}
*/
func (a *ManagedControllerApiService) DiffManifestUsingPOST(ctx context.Context, manifest DeliveryConfig) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/delivery-configs/diff"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &manifest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Ad-hoc validate and diff a resource
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param resource resource

@return interface{}
*/
func (a *ManagedControllerApiService) DiffResourceUsingPOST(ctx context.Context, resource Resource) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/resources/diff"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &resource
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Generates an artifact definition based on the artifact used in a running cluster
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param account account
 * @param cloudProvider cloudProvider
 * @param clusterName clusterName

@return interface{}
*/
func (a *ManagedControllerApiService) ExportResourceUsingGET(ctx context.Context, account string, cloudProvider string, clusterName string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/resources/export/artifact/{cloudProvider}/{account}/{clusterName}"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", fmt.Sprintf("%v", account), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", fmt.Sprintf("%v", cloudProvider), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clusterName"+"}", fmt.Sprintf("%v", clusterName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Generate a keel resource definition for a deployed cloud resource
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param account account
 * @param cloudProvider cloudProvider
 * @param name name
 * @param serviceAccount serviceAccount
 * @param type_ type

@return Resource
*/
func (a *ManagedControllerApiService) ExportResourceUsingGET1(ctx context.Context, account string, cloudProvider string, name string, serviceAccount string, type_ string) (Resource, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Resource
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/resources/export/{cloudProvider}/{account}/{type}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", fmt.Sprintf("%v", account), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", fmt.Sprintf("%v", cloudProvider), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", fmt.Sprintf("%v", type_), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("serviceAccount", parameterToString(serviceAccount, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Resource
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get a report of Managed Delivery adoption
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param params params

@return string
*/
func (a *ManagedControllerApiService) GetAdoptionReportUsingGET(ctx context.Context, params interface{}) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/reports/adoption"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("params", parameterToString(params, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get managed details about an application
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param optional nil or *ManagedControllerApiGetApplicationDetailsUsingGETOpts - Optional Parameters:
     * @param "Entities" (optional.Interface of []string) -  entities
     * @param "IncludeDetails" (optional.Bool) -  includeDetails
     * @param "MaxArtifactVersions" (optional.Int32) -  maxArtifactVersions

@return interface{}
*/

type ManagedControllerApiGetApplicationDetailsUsingGETOpts struct { 
	Entities optional.Interface
	IncludeDetails optional.Bool
	MaxArtifactVersions optional.Int32
}

func (a *ManagedControllerApiService) GetApplicationDetailsUsingGET(ctx context.Context, application string, localVarOptionals *ManagedControllerApiGetApplicationDetailsUsingGETOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Entities.IsSet() {
		localVarQueryParams.Add("entities", parameterToString(localVarOptionals.Entities.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeDetails.IsSet() {
		localVarQueryParams.Add("includeDetails", parameterToString(localVarOptionals.IncludeDetails.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxArtifactVersions.IsSet() {
		localVarQueryParams.Add("maxArtifactVersions", parameterToString(localVarOptionals.MaxArtifactVersions.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get the delivery config associated with an application
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application

@return DeliveryConfig
*/
func (a *ManagedControllerApiService) GetConfigByUsingGET(ctx context.Context, application string) (DeliveryConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeliveryConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DeliveryConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService List up-to {limit} current constraint states for an environment
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param environment environment
 * @param optional nil or *ManagedControllerApiGetConstraintStateUsingGETOpts - Optional Parameters:
     * @param "Limit" (optional.String) -  limit

@return ConstraintState
*/

type ManagedControllerApiGetConstraintStateUsingGETOpts struct { 
	Limit optional.String
}

func (a *ManagedControllerApiService) GetConstraintStateUsingGET(ctx context.Context, application string, environment string, localVarOptionals *ManagedControllerApiGetConstraintStateUsingGETOpts) (ConstraintState, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConstraintState
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/environment/{environment}/constraints"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment"+"}", fmt.Sprintf("%v", environment), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ConstraintState
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get current environment details
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application

@return []Mapstringobject
*/
func (a *ManagedControllerApiService) GetEnvironmentsUsingGET(ctx context.Context, application string) ([]Mapstringobject, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Mapstringobject
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/environments/{application}"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []Mapstringobject
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get the status of each version of each artifact in each environment
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name

@return []interface{}
*/
func (a *ManagedControllerApiService) GetManifestArtifactsUsingGET(ctx context.Context, name string) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/delivery-configs/{name}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get a delivery config manifest
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name

@return DeliveryConfig
*/
func (a *ManagedControllerApiService) GetManifestUsingGET(ctx context.Context, name string) (DeliveryConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeliveryConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/delivery-configs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DeliveryConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get a delivery config manifest
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name

@return DeliveryConfig
*/
func (a *ManagedControllerApiService) GetManifestYamlUsingGET(ctx context.Context, name string) (DeliveryConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeliveryConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/delivery-configs/{name}.yml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/x-yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DeliveryConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get a report of application onboarding
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accept Accept
 * @param params params

@return string
*/
func (a *ManagedControllerApiService) GetOnboardingReportUsingGET(ctx context.Context, accept string, params interface{}) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/reports/onboarding"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("params", parameterToString(params, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Accept"] = parameterToString(accept, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get status of a resource
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param resourceId resourceId

@return interface{}
*/
func (a *ManagedControllerApiService) GetResourceStatusUsingGET(ctx context.Context, resourceId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/resources/{resourceId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceId"+"}", fmt.Sprintf("%v", resourceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get a resource
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param resourceId resourceId

@return Resource
*/
func (a *ManagedControllerApiService) GetResourceUsingGET(ctx context.Context, resourceId string) (Resource, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Resource
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/resources/{resourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceId"+"}", fmt.Sprintf("%v", resourceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Resource
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Get a resource
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param resourceId resourceId

@return Resource
*/
func (a *ManagedControllerApiService) GetResourceYamlUsingGET(ctx context.Context, resourceId string) (Resource, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Resource
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/resources/{resourceId}.yml"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceId"+"}", fmt.Sprintf("%v", resourceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/x-yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Resource
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Veto an artifact version in an environment
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param veto veto


*/
func (a *ManagedControllerApiService) MarkBadUsingPOST(ctx context.Context, application string, veto EnvironmentArtifactVeto) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/mark/bad"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &veto
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Delete veto of an artifact version in an environment
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param veto veto


*/
func (a *ManagedControllerApiService) MarkGoodUsingPOST(ctx context.Context, application string, veto EnvironmentArtifactVeto) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/mark/good"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &veto
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Override the status of a verification
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param environment environment
 * @param payload payload


*/
func (a *ManagedControllerApiService) OverrideVerificationUsingPOST(ctx context.Context, application string, environment string, payload OverrideVerificationRequest) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/{application}/environment/{environment}/verifications"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment"+"}", fmt.Sprintf("%v", environment), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &payload
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Pause management of an entire application
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application


*/
func (a *ManagedControllerApiService) PauseApplicationUsingPOST(ctx context.Context, application string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Pause management of a resource
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param resourceId resourceId


*/
func (a *ManagedControllerApiService) PauseResourceUsingPOST(ctx context.Context, resourceId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/resources/{resourceId}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceId"+"}", fmt.Sprintf("%v", resourceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService processNotificationCallback
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param source source
 * @param optional nil or *ManagedControllerApiProcessNotificationCallbackUsingPOSTOpts - Optional Parameters:
     * @param "Body" (optional.String) - 
     * @param "HeadersETag" (optional.String) - 
     * @param "HeadersAcceptCharset0Registered" (optional.Bool) - 
     * @param "HeadersAcceptLanguageAsLocales0ISO3Country" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0ISO3Language" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0Country" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0DisplayCountry" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0DisplayLanguage" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0DisplayName" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0DisplayScript" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0DisplayVariant" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0Language" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0Script" (optional.String) - 
     * @param "HeadersAcceptLanguageAsLocales0UnicodeLocaleAttributes" (optional.Interface of []string) - 
     * @param "HeadersAcceptLanguageAsLocales0UnicodeLocaleKeys" (optional.Interface of []string) - 
     * @param "HeadersAcceptLanguageAsLocales0Variant" (optional.String) - 
     * @param "HeadersAcceptLanguage0Range" (optional.String) - 
     * @param "HeadersAcceptLanguage0Weight" (optional.Float64) - 
     * @param "HeadersAccept0CharsetRegistered" (optional.Bool) - 
     * @param "HeadersAccept0Concrete" (optional.Bool) - 
     * @param "HeadersAccept0QualityValue" (optional.Float64) - 
     * @param "HeadersAccept0Subtype" (optional.String) - 
     * @param "HeadersAccept0Type" (optional.String) - 
     * @param "HeadersAccept0WildcardSubtype" (optional.Bool) - 
     * @param "HeadersAccept0WildcardType" (optional.Bool) - 
     * @param "HeadersAccessControlAllowCredentials" (optional.Bool) - 
     * @param "HeadersAccessControlAllowHeaders" (optional.Interface of []string) - 
     * @param "HeadersAccessControlAllowMethods" (optional.Interface of []string) - 
     * @param "HeadersAccessControlAllowOrigin" (optional.String) - 
     * @param "HeadersAccessControlExposeHeaders" (optional.Interface of []string) - 
     * @param "HeadersAccessControlMaxAge" (optional.Int64) - 
     * @param "HeadersAccessControlRequestHeaders" (optional.Interface of []string) - 
     * @param "HeadersAccessControlRequestMethod" (optional.String) - 
     * @param "HeadersAllow" (optional.Interface of []string) - 
     * @param "HeadersCacheControl" (optional.String) - 
     * @param "HeadersConnection" (optional.Interface of []string) - 
     * @param "HeadersContentDispositionCharsetRegistered" (optional.Bool) - 
     * @param "HeadersContentDispositionCreationDate" (optional.Time) - 
     * @param "HeadersContentDispositionFilename" (optional.String) - 
     * @param "HeadersContentDispositionModificationDate" (optional.Time) - 
     * @param "HeadersContentDispositionName" (optional.String) - 
     * @param "HeadersContentDispositionReadDate" (optional.Time) - 
     * @param "HeadersContentDispositionSize" (optional.Int64) - 
     * @param "HeadersContentDispositionType" (optional.String) - 
     * @param "HeadersContentLanguageISO3Country" (optional.String) - 
     * @param "HeadersContentLanguageISO3Language" (optional.String) - 
     * @param "HeadersContentLanguageCountry" (optional.String) - 
     * @param "HeadersContentLanguageDisplayCountry" (optional.String) - 
     * @param "HeadersContentLanguageDisplayLanguage" (optional.String) - 
     * @param "HeadersContentLanguageDisplayName" (optional.String) - 
     * @param "HeadersContentLanguageDisplayScript" (optional.String) - 
     * @param "HeadersContentLanguageDisplayVariant" (optional.String) - 
     * @param "HeadersContentLanguageLanguage" (optional.String) - 
     * @param "HeadersContentLanguageScript" (optional.String) - 
     * @param "HeadersContentLanguageUnicodeLocaleAttributes" (optional.Interface of []string) - 
     * @param "HeadersContentLanguageUnicodeLocaleKeys" (optional.Interface of []string) - 
     * @param "HeadersContentLanguageVariant" (optional.String) - 
     * @param "HeadersContentLength" (optional.Int64) - 
     * @param "HeadersContentTypeCharsetRegistered" (optional.Bool) - 
     * @param "HeadersContentTypeConcrete" (optional.Bool) - 
     * @param "HeadersContentTypeQualityValue" (optional.Float64) - 
     * @param "HeadersContentTypeSubtype" (optional.String) - 
     * @param "HeadersContentTypeType" (optional.String) - 
     * @param "HeadersContentTypeWildcardSubtype" (optional.Bool) - 
     * @param "HeadersContentTypeWildcardType" (optional.Bool) - 
     * @param "HeadersDate" (optional.Int64) - 
     * @param "HeadersExpires" (optional.Int64) - 
     * @param "HeadersHostAddressMCGlobal" (optional.Bool) - 
     * @param "HeadersHostAddressMCLinkLocal" (optional.Bool) - 
     * @param "HeadersHostAddressMCNodeLocal" (optional.Bool) - 
     * @param "HeadersHostAddressMCOrgLocal" (optional.Bool) - 
     * @param "HeadersHostAddressMCSiteLocal" (optional.Bool) - 
     * @param "HeadersHostAddressAddress" (optional.String) - 
     * @param "HeadersHostAddressAnyLocalAddress" (optional.Bool) - 
     * @param "HeadersHostAddressCanonicalHostName" (optional.String) - 
     * @param "HeadersHostAddressHostAddress" (optional.String) - 
     * @param "HeadersHostAddressHostName" (optional.String) - 
     * @param "HeadersHostAddressLinkLocalAddress" (optional.Bool) - 
     * @param "HeadersHostAddressLoopbackAddress" (optional.Bool) - 
     * @param "HeadersHostAddressMulticastAddress" (optional.Bool) - 
     * @param "HeadersHostAddressSiteLocalAddress" (optional.Bool) - 
     * @param "HeadersHostHostName" (optional.String) - 
     * @param "HeadersHostHostString" (optional.String) - 
     * @param "HeadersHostPort" (optional.Int32) - 
     * @param "HeadersHostUnresolved" (optional.Bool) - 
     * @param "HeadersIfMatch" (optional.Interface of []string) - 
     * @param "HeadersIfModifiedSince" (optional.Int64) - 
     * @param "HeadersIfNoneMatch" (optional.Interface of []string) - 
     * @param "HeadersIfUnmodifiedSince" (optional.Int64) - 
     * @param "HeadersLastModified" (optional.Int64) - 
     * @param "HeadersLocationAbsolute" (optional.Bool) - 
     * @param "HeadersLocationAuthority" (optional.String) - 
     * @param "HeadersLocationFragment" (optional.String) - 
     * @param "HeadersLocationHost" (optional.String) - 
     * @param "HeadersLocationOpaque" (optional.Bool) - 
     * @param "HeadersLocationPath" (optional.String) - 
     * @param "HeadersLocationPort" (optional.Int32) - 
     * @param "HeadersLocationQuery" (optional.String) - 
     * @param "HeadersLocationRawAuthority" (optional.String) - 
     * @param "HeadersLocationRawFragment" (optional.String) - 
     * @param "HeadersLocationRawPath" (optional.String) - 
     * @param "HeadersLocationRawQuery" (optional.String) - 
     * @param "HeadersLocationRawSchemeSpecificPart" (optional.String) - 
     * @param "HeadersLocationRawUserInfo" (optional.String) - 
     * @param "HeadersLocationScheme" (optional.String) - 
     * @param "HeadersLocationSchemeSpecificPart" (optional.String) - 
     * @param "HeadersLocationUserInfo" (optional.String) - 
     * @param "HeadersOrigin" (optional.String) - 
     * @param "HeadersPragma" (optional.String) - 
     * @param "HeadersUpgrade" (optional.String) - 
     * @param "HeadersVary" (optional.Interface of []string) - 
     * @param "Method" (optional.String) - 
     * @param "Type_" (optional.Interface of Object) - 
     * @param "UrlAbsolute" (optional.Bool) - 
     * @param "UrlAuthority" (optional.String) - 
     * @param "UrlFragment" (optional.String) - 
     * @param "UrlHost" (optional.String) - 
     * @param "UrlOpaque" (optional.Bool) - 
     * @param "UrlPath" (optional.String) - 
     * @param "UrlPort" (optional.Int32) - 
     * @param "UrlQuery" (optional.String) - 
     * @param "UrlRawAuthority" (optional.String) - 
     * @param "UrlRawFragment" (optional.String) - 
     * @param "UrlRawPath" (optional.String) - 
     * @param "UrlRawQuery" (optional.String) - 
     * @param "UrlRawSchemeSpecificPart" (optional.String) - 
     * @param "UrlRawUserInfo" (optional.String) - 
     * @param "UrlScheme" (optional.String) - 
     * @param "UrlSchemeSpecificPart" (optional.String) - 
     * @param "UrlUserInfo" (optional.String) - 

@return string
*/

type ManagedControllerApiProcessNotificationCallbackUsingPOSTOpts struct { 
	Body optional.String
	HeadersETag optional.String
	HeadersAcceptCharset0Registered optional.Bool
	HeadersAcceptLanguageAsLocales0ISO3Country optional.String
	HeadersAcceptLanguageAsLocales0ISO3Language optional.String
	HeadersAcceptLanguageAsLocales0Country optional.String
	HeadersAcceptLanguageAsLocales0DisplayCountry optional.String
	HeadersAcceptLanguageAsLocales0DisplayLanguage optional.String
	HeadersAcceptLanguageAsLocales0DisplayName optional.String
	HeadersAcceptLanguageAsLocales0DisplayScript optional.String
	HeadersAcceptLanguageAsLocales0DisplayVariant optional.String
	HeadersAcceptLanguageAsLocales0Language optional.String
	HeadersAcceptLanguageAsLocales0Script optional.String
	HeadersAcceptLanguageAsLocales0UnicodeLocaleAttributes optional.Interface
	HeadersAcceptLanguageAsLocales0UnicodeLocaleKeys optional.Interface
	HeadersAcceptLanguageAsLocales0Variant optional.String
	HeadersAcceptLanguage0Range optional.String
	HeadersAcceptLanguage0Weight optional.Float64
	HeadersAccept0CharsetRegistered optional.Bool
	HeadersAccept0Concrete optional.Bool
	HeadersAccept0QualityValue optional.Float64
	HeadersAccept0Subtype optional.String
	HeadersAccept0Type optional.String
	HeadersAccept0WildcardSubtype optional.Bool
	HeadersAccept0WildcardType optional.Bool
	HeadersAccessControlAllowCredentials optional.Bool
	HeadersAccessControlAllowHeaders optional.Interface
	HeadersAccessControlAllowMethods optional.Interface
	HeadersAccessControlAllowOrigin optional.String
	HeadersAccessControlExposeHeaders optional.Interface
	HeadersAccessControlMaxAge optional.Int64
	HeadersAccessControlRequestHeaders optional.Interface
	HeadersAccessControlRequestMethod optional.String
	HeadersAllow optional.Interface
	HeadersCacheControl optional.String
	HeadersConnection optional.Interface
	HeadersContentDispositionCharsetRegistered optional.Bool
	HeadersContentDispositionCreationDate optional.Time
	HeadersContentDispositionFilename optional.String
	HeadersContentDispositionModificationDate optional.Time
	HeadersContentDispositionName optional.String
	HeadersContentDispositionReadDate optional.Time
	HeadersContentDispositionSize optional.Int64
	HeadersContentDispositionType optional.String
	HeadersContentLanguageISO3Country optional.String
	HeadersContentLanguageISO3Language optional.String
	HeadersContentLanguageCountry optional.String
	HeadersContentLanguageDisplayCountry optional.String
	HeadersContentLanguageDisplayLanguage optional.String
	HeadersContentLanguageDisplayName optional.String
	HeadersContentLanguageDisplayScript optional.String
	HeadersContentLanguageDisplayVariant optional.String
	HeadersContentLanguageLanguage optional.String
	HeadersContentLanguageScript optional.String
	HeadersContentLanguageUnicodeLocaleAttributes optional.Interface
	HeadersContentLanguageUnicodeLocaleKeys optional.Interface
	HeadersContentLanguageVariant optional.String
	HeadersContentLength optional.Int64
	HeadersContentTypeCharsetRegistered optional.Bool
	HeadersContentTypeConcrete optional.Bool
	HeadersContentTypeQualityValue optional.Float64
	HeadersContentTypeSubtype optional.String
	HeadersContentTypeType optional.String
	HeadersContentTypeWildcardSubtype optional.Bool
	HeadersContentTypeWildcardType optional.Bool
	HeadersDate optional.Int64
	HeadersExpires optional.Int64
	HeadersHostAddressMCGlobal optional.Bool
	HeadersHostAddressMCLinkLocal optional.Bool
	HeadersHostAddressMCNodeLocal optional.Bool
	HeadersHostAddressMCOrgLocal optional.Bool
	HeadersHostAddressMCSiteLocal optional.Bool
	HeadersHostAddressAddress optional.String
	HeadersHostAddressAnyLocalAddress optional.Bool
	HeadersHostAddressCanonicalHostName optional.String
	HeadersHostAddressHostAddress optional.String
	HeadersHostAddressHostName optional.String
	HeadersHostAddressLinkLocalAddress optional.Bool
	HeadersHostAddressLoopbackAddress optional.Bool
	HeadersHostAddressMulticastAddress optional.Bool
	HeadersHostAddressSiteLocalAddress optional.Bool
	HeadersHostHostName optional.String
	HeadersHostHostString optional.String
	HeadersHostPort optional.Int32
	HeadersHostUnresolved optional.Bool
	HeadersIfMatch optional.Interface
	HeadersIfModifiedSince optional.Int64
	HeadersIfNoneMatch optional.Interface
	HeadersIfUnmodifiedSince optional.Int64
	HeadersLastModified optional.Int64
	HeadersLocationAbsolute optional.Bool
	HeadersLocationAuthority optional.String
	HeadersLocationFragment optional.String
	HeadersLocationHost optional.String
	HeadersLocationOpaque optional.Bool
	HeadersLocationPath optional.String
	HeadersLocationPort optional.Int32
	HeadersLocationQuery optional.String
	HeadersLocationRawAuthority optional.String
	HeadersLocationRawFragment optional.String
	HeadersLocationRawPath optional.String
	HeadersLocationRawQuery optional.String
	HeadersLocationRawSchemeSpecificPart optional.String
	HeadersLocationRawUserInfo optional.String
	HeadersLocationScheme optional.String
	HeadersLocationSchemeSpecificPart optional.String
	HeadersLocationUserInfo optional.String
	HeadersOrigin optional.String
	HeadersPragma optional.String
	HeadersUpgrade optional.String
	HeadersVary optional.Interface
	Method optional.String
	Type_ optional.Interface
	UrlAbsolute optional.Bool
	UrlAuthority optional.String
	UrlFragment optional.String
	UrlHost optional.String
	UrlOpaque optional.Bool
	UrlPath optional.String
	UrlPort optional.Int32
	UrlQuery optional.String
	UrlRawAuthority optional.String
	UrlRawFragment optional.String
	UrlRawPath optional.String
	UrlRawQuery optional.String
	UrlRawSchemeSpecificPart optional.String
	UrlRawUserInfo optional.String
	UrlScheme optional.String
	UrlSchemeSpecificPart optional.String
	UrlUserInfo optional.String
}

func (a *ManagedControllerApiService) ProcessNotificationCallbackUsingPOST(ctx context.Context, source string, localVarOptionals *ManagedControllerApiProcessNotificationCallbackUsingPOSTOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/notifications/callbacks/{source}"
	localVarPath = strings.Replace(localVarPath, "{"+"source"+"}", fmt.Sprintf("%v", source), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarFormParams.Add("body", parameterToString(localVarOptionals.Body.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersETag.IsSet() {
		localVarFormParams.Add("headers.ETag", parameterToString(localVarOptionals.HeadersETag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptCharset0Registered.IsSet() {
		localVarFormParams.Add("headers.acceptCharset[0].registered", parameterToString(localVarOptionals.HeadersAcceptCharset0Registered.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0ISO3Country.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].ISO3Country", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0ISO3Country.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0ISO3Language.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].ISO3Language", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0ISO3Language.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0Country.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].country", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0Country.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayCountry.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].displayCountry", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayCountry.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayLanguage.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].displayLanguage", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayLanguage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayName.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].displayName", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayScript.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].displayScript", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayScript.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayVariant.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].displayVariant", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0DisplayVariant.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0Language.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].language", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0Language.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0Script.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].script", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0Script.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0UnicodeLocaleAttributes.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].unicodeLocaleAttributes", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0UnicodeLocaleAttributes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0UnicodeLocaleKeys.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].unicodeLocaleKeys", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0UnicodeLocaleKeys.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguageAsLocales0Variant.IsSet() {
		localVarFormParams.Add("headers.acceptLanguageAsLocales[0].variant", parameterToString(localVarOptionals.HeadersAcceptLanguageAsLocales0Variant.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguage0Range.IsSet() {
		localVarFormParams.Add("headers.acceptLanguage[0].range", parameterToString(localVarOptionals.HeadersAcceptLanguage0Range.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAcceptLanguage0Weight.IsSet() {
		localVarFormParams.Add("headers.acceptLanguage[0].weight", parameterToString(localVarOptionals.HeadersAcceptLanguage0Weight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccept0CharsetRegistered.IsSet() {
		localVarFormParams.Add("headers.accept[0].charset.registered", parameterToString(localVarOptionals.HeadersAccept0CharsetRegistered.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccept0Concrete.IsSet() {
		localVarFormParams.Add("headers.accept[0].concrete", parameterToString(localVarOptionals.HeadersAccept0Concrete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccept0QualityValue.IsSet() {
		localVarFormParams.Add("headers.accept[0].qualityValue", parameterToString(localVarOptionals.HeadersAccept0QualityValue.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccept0Subtype.IsSet() {
		localVarFormParams.Add("headers.accept[0].subtype", parameterToString(localVarOptionals.HeadersAccept0Subtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccept0Type.IsSet() {
		localVarFormParams.Add("headers.accept[0].type", parameterToString(localVarOptionals.HeadersAccept0Type.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccept0WildcardSubtype.IsSet() {
		localVarFormParams.Add("headers.accept[0].wildcardSubtype", parameterToString(localVarOptionals.HeadersAccept0WildcardSubtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccept0WildcardType.IsSet() {
		localVarFormParams.Add("headers.accept[0].wildcardType", parameterToString(localVarOptionals.HeadersAccept0WildcardType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccessControlAllowCredentials.IsSet() {
		localVarFormParams.Add("headers.accessControlAllowCredentials", parameterToString(localVarOptionals.HeadersAccessControlAllowCredentials.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccessControlAllowHeaders.IsSet() {
		localVarFormParams.Add("headers.accessControlAllowHeaders", parameterToString(localVarOptionals.HeadersAccessControlAllowHeaders.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccessControlAllowMethods.IsSet() {
		localVarFormParams.Add("headers.accessControlAllowMethods", parameterToString(localVarOptionals.HeadersAccessControlAllowMethods.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccessControlAllowOrigin.IsSet() {
		localVarFormParams.Add("headers.accessControlAllowOrigin", parameterToString(localVarOptionals.HeadersAccessControlAllowOrigin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccessControlExposeHeaders.IsSet() {
		localVarFormParams.Add("headers.accessControlExposeHeaders", parameterToString(localVarOptionals.HeadersAccessControlExposeHeaders.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccessControlMaxAge.IsSet() {
		localVarFormParams.Add("headers.accessControlMaxAge", parameterToString(localVarOptionals.HeadersAccessControlMaxAge.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccessControlRequestHeaders.IsSet() {
		localVarFormParams.Add("headers.accessControlRequestHeaders", parameterToString(localVarOptionals.HeadersAccessControlRequestHeaders.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAccessControlRequestMethod.IsSet() {
		localVarFormParams.Add("headers.accessControlRequestMethod", parameterToString(localVarOptionals.HeadersAccessControlRequestMethod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersAllow.IsSet() {
		localVarFormParams.Add("headers.allow", parameterToString(localVarOptionals.HeadersAllow.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersCacheControl.IsSet() {
		localVarFormParams.Add("headers.cacheControl", parameterToString(localVarOptionals.HeadersCacheControl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersConnection.IsSet() {
		localVarFormParams.Add("headers.connection", parameterToString(localVarOptionals.HeadersConnection.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentDispositionCharsetRegistered.IsSet() {
		localVarFormParams.Add("headers.contentDisposition.charset.registered", parameterToString(localVarOptionals.HeadersContentDispositionCharsetRegistered.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentDispositionCreationDate.IsSet() {
		localVarFormParams.Add("headers.contentDisposition.creationDate", parameterToString(localVarOptionals.HeadersContentDispositionCreationDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentDispositionFilename.IsSet() {
		localVarFormParams.Add("headers.contentDisposition.filename", parameterToString(localVarOptionals.HeadersContentDispositionFilename.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentDispositionModificationDate.IsSet() {
		localVarFormParams.Add("headers.contentDisposition.modificationDate", parameterToString(localVarOptionals.HeadersContentDispositionModificationDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentDispositionName.IsSet() {
		localVarFormParams.Add("headers.contentDisposition.name", parameterToString(localVarOptionals.HeadersContentDispositionName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentDispositionReadDate.IsSet() {
		localVarFormParams.Add("headers.contentDisposition.readDate", parameterToString(localVarOptionals.HeadersContentDispositionReadDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentDispositionSize.IsSet() {
		localVarFormParams.Add("headers.contentDisposition.size", parameterToString(localVarOptionals.HeadersContentDispositionSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentDispositionType.IsSet() {
		localVarFormParams.Add("headers.contentDisposition.type", parameterToString(localVarOptionals.HeadersContentDispositionType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageISO3Country.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.ISO3Country", parameterToString(localVarOptionals.HeadersContentLanguageISO3Country.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageISO3Language.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.ISO3Language", parameterToString(localVarOptionals.HeadersContentLanguageISO3Language.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageCountry.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.country", parameterToString(localVarOptionals.HeadersContentLanguageCountry.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageDisplayCountry.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.displayCountry", parameterToString(localVarOptionals.HeadersContentLanguageDisplayCountry.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageDisplayLanguage.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.displayLanguage", parameterToString(localVarOptionals.HeadersContentLanguageDisplayLanguage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageDisplayName.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.displayName", parameterToString(localVarOptionals.HeadersContentLanguageDisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageDisplayScript.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.displayScript", parameterToString(localVarOptionals.HeadersContentLanguageDisplayScript.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageDisplayVariant.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.displayVariant", parameterToString(localVarOptionals.HeadersContentLanguageDisplayVariant.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageLanguage.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.language", parameterToString(localVarOptionals.HeadersContentLanguageLanguage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageScript.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.script", parameterToString(localVarOptionals.HeadersContentLanguageScript.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageUnicodeLocaleAttributes.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.unicodeLocaleAttributes", parameterToString(localVarOptionals.HeadersContentLanguageUnicodeLocaleAttributes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageUnicodeLocaleKeys.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.unicodeLocaleKeys", parameterToString(localVarOptionals.HeadersContentLanguageUnicodeLocaleKeys.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLanguageVariant.IsSet() {
		localVarFormParams.Add("headers.contentLanguage.variant", parameterToString(localVarOptionals.HeadersContentLanguageVariant.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentLength.IsSet() {
		localVarFormParams.Add("headers.contentLength", parameterToString(localVarOptionals.HeadersContentLength.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentTypeCharsetRegistered.IsSet() {
		localVarFormParams.Add("headers.contentType.charset.registered", parameterToString(localVarOptionals.HeadersContentTypeCharsetRegistered.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentTypeConcrete.IsSet() {
		localVarFormParams.Add("headers.contentType.concrete", parameterToString(localVarOptionals.HeadersContentTypeConcrete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentTypeQualityValue.IsSet() {
		localVarFormParams.Add("headers.contentType.qualityValue", parameterToString(localVarOptionals.HeadersContentTypeQualityValue.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentTypeSubtype.IsSet() {
		localVarFormParams.Add("headers.contentType.subtype", parameterToString(localVarOptionals.HeadersContentTypeSubtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentTypeType.IsSet() {
		localVarFormParams.Add("headers.contentType.type", parameterToString(localVarOptionals.HeadersContentTypeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentTypeWildcardSubtype.IsSet() {
		localVarFormParams.Add("headers.contentType.wildcardSubtype", parameterToString(localVarOptionals.HeadersContentTypeWildcardSubtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersContentTypeWildcardType.IsSet() {
		localVarFormParams.Add("headers.contentType.wildcardType", parameterToString(localVarOptionals.HeadersContentTypeWildcardType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersDate.IsSet() {
		localVarFormParams.Add("headers.date", parameterToString(localVarOptionals.HeadersDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersExpires.IsSet() {
		localVarFormParams.Add("headers.expires", parameterToString(localVarOptionals.HeadersExpires.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressMCGlobal.IsSet() {
		localVarFormParams.Add("headers.host.address.MCGlobal", parameterToString(localVarOptionals.HeadersHostAddressMCGlobal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressMCLinkLocal.IsSet() {
		localVarFormParams.Add("headers.host.address.MCLinkLocal", parameterToString(localVarOptionals.HeadersHostAddressMCLinkLocal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressMCNodeLocal.IsSet() {
		localVarFormParams.Add("headers.host.address.MCNodeLocal", parameterToString(localVarOptionals.HeadersHostAddressMCNodeLocal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressMCOrgLocal.IsSet() {
		localVarFormParams.Add("headers.host.address.MCOrgLocal", parameterToString(localVarOptionals.HeadersHostAddressMCOrgLocal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressMCSiteLocal.IsSet() {
		localVarFormParams.Add("headers.host.address.MCSiteLocal", parameterToString(localVarOptionals.HeadersHostAddressMCSiteLocal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressAddress.IsSet() {
		localVarFormParams.Add("headers.host.address.address", parameterToString(localVarOptionals.HeadersHostAddressAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressAnyLocalAddress.IsSet() {
		localVarFormParams.Add("headers.host.address.anyLocalAddress", parameterToString(localVarOptionals.HeadersHostAddressAnyLocalAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressCanonicalHostName.IsSet() {
		localVarFormParams.Add("headers.host.address.canonicalHostName", parameterToString(localVarOptionals.HeadersHostAddressCanonicalHostName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressHostAddress.IsSet() {
		localVarFormParams.Add("headers.host.address.hostAddress", parameterToString(localVarOptionals.HeadersHostAddressHostAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressHostName.IsSet() {
		localVarFormParams.Add("headers.host.address.hostName", parameterToString(localVarOptionals.HeadersHostAddressHostName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressLinkLocalAddress.IsSet() {
		localVarFormParams.Add("headers.host.address.linkLocalAddress", parameterToString(localVarOptionals.HeadersHostAddressLinkLocalAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressLoopbackAddress.IsSet() {
		localVarFormParams.Add("headers.host.address.loopbackAddress", parameterToString(localVarOptionals.HeadersHostAddressLoopbackAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressMulticastAddress.IsSet() {
		localVarFormParams.Add("headers.host.address.multicastAddress", parameterToString(localVarOptionals.HeadersHostAddressMulticastAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostAddressSiteLocalAddress.IsSet() {
		localVarFormParams.Add("headers.host.address.siteLocalAddress", parameterToString(localVarOptionals.HeadersHostAddressSiteLocalAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostHostName.IsSet() {
		localVarFormParams.Add("headers.host.hostName", parameterToString(localVarOptionals.HeadersHostHostName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostHostString.IsSet() {
		localVarFormParams.Add("headers.host.hostString", parameterToString(localVarOptionals.HeadersHostHostString.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostPort.IsSet() {
		localVarFormParams.Add("headers.host.port", parameterToString(localVarOptionals.HeadersHostPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersHostUnresolved.IsSet() {
		localVarFormParams.Add("headers.host.unresolved", parameterToString(localVarOptionals.HeadersHostUnresolved.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersIfMatch.IsSet() {
		localVarFormParams.Add("headers.ifMatch", parameterToString(localVarOptionals.HeadersIfMatch.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersIfModifiedSince.IsSet() {
		localVarFormParams.Add("headers.ifModifiedSince", parameterToString(localVarOptionals.HeadersIfModifiedSince.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersIfNoneMatch.IsSet() {
		localVarFormParams.Add("headers.ifNoneMatch", parameterToString(localVarOptionals.HeadersIfNoneMatch.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersIfUnmodifiedSince.IsSet() {
		localVarFormParams.Add("headers.ifUnmodifiedSince", parameterToString(localVarOptionals.HeadersIfUnmodifiedSince.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLastModified.IsSet() {
		localVarFormParams.Add("headers.lastModified", parameterToString(localVarOptionals.HeadersLastModified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationAbsolute.IsSet() {
		localVarFormParams.Add("headers.location.absolute", parameterToString(localVarOptionals.HeadersLocationAbsolute.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationAuthority.IsSet() {
		localVarFormParams.Add("headers.location.authority", parameterToString(localVarOptionals.HeadersLocationAuthority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationFragment.IsSet() {
		localVarFormParams.Add("headers.location.fragment", parameterToString(localVarOptionals.HeadersLocationFragment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationHost.IsSet() {
		localVarFormParams.Add("headers.location.host", parameterToString(localVarOptionals.HeadersLocationHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationOpaque.IsSet() {
		localVarFormParams.Add("headers.location.opaque", parameterToString(localVarOptionals.HeadersLocationOpaque.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationPath.IsSet() {
		localVarFormParams.Add("headers.location.path", parameterToString(localVarOptionals.HeadersLocationPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationPort.IsSet() {
		localVarFormParams.Add("headers.location.port", parameterToString(localVarOptionals.HeadersLocationPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationQuery.IsSet() {
		localVarFormParams.Add("headers.location.query", parameterToString(localVarOptionals.HeadersLocationQuery.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationRawAuthority.IsSet() {
		localVarFormParams.Add("headers.location.rawAuthority", parameterToString(localVarOptionals.HeadersLocationRawAuthority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationRawFragment.IsSet() {
		localVarFormParams.Add("headers.location.rawFragment", parameterToString(localVarOptionals.HeadersLocationRawFragment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationRawPath.IsSet() {
		localVarFormParams.Add("headers.location.rawPath", parameterToString(localVarOptionals.HeadersLocationRawPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationRawQuery.IsSet() {
		localVarFormParams.Add("headers.location.rawQuery", parameterToString(localVarOptionals.HeadersLocationRawQuery.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationRawSchemeSpecificPart.IsSet() {
		localVarFormParams.Add("headers.location.rawSchemeSpecificPart", parameterToString(localVarOptionals.HeadersLocationRawSchemeSpecificPart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationRawUserInfo.IsSet() {
		localVarFormParams.Add("headers.location.rawUserInfo", parameterToString(localVarOptionals.HeadersLocationRawUserInfo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationScheme.IsSet() {
		localVarFormParams.Add("headers.location.scheme", parameterToString(localVarOptionals.HeadersLocationScheme.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationSchemeSpecificPart.IsSet() {
		localVarFormParams.Add("headers.location.schemeSpecificPart", parameterToString(localVarOptionals.HeadersLocationSchemeSpecificPart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersLocationUserInfo.IsSet() {
		localVarFormParams.Add("headers.location.userInfo", parameterToString(localVarOptionals.HeadersLocationUserInfo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersOrigin.IsSet() {
		localVarFormParams.Add("headers.origin", parameterToString(localVarOptionals.HeadersOrigin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersPragma.IsSet() {
		localVarFormParams.Add("headers.pragma", parameterToString(localVarOptionals.HeadersPragma.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersUpgrade.IsSet() {
		localVarFormParams.Add("headers.upgrade", parameterToString(localVarOptionals.HeadersUpgrade.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeadersVary.IsSet() {
		localVarFormParams.Add("headers.vary", parameterToString(localVarOptionals.HeadersVary.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Method.IsSet() {
		localVarFormParams.Add("method", parameterToString(localVarOptionals.Method.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlAbsolute.IsSet() {
		localVarFormParams.Add("url.absolute", parameterToString(localVarOptionals.UrlAbsolute.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlAuthority.IsSet() {
		localVarFormParams.Add("url.authority", parameterToString(localVarOptionals.UrlAuthority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlFragment.IsSet() {
		localVarFormParams.Add("url.fragment", parameterToString(localVarOptionals.UrlFragment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlHost.IsSet() {
		localVarFormParams.Add("url.host", parameterToString(localVarOptionals.UrlHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlOpaque.IsSet() {
		localVarFormParams.Add("url.opaque", parameterToString(localVarOptionals.UrlOpaque.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlPath.IsSet() {
		localVarFormParams.Add("url.path", parameterToString(localVarOptionals.UrlPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlPort.IsSet() {
		localVarFormParams.Add("url.port", parameterToString(localVarOptionals.UrlPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlQuery.IsSet() {
		localVarFormParams.Add("url.query", parameterToString(localVarOptionals.UrlQuery.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlRawAuthority.IsSet() {
		localVarFormParams.Add("url.rawAuthority", parameterToString(localVarOptionals.UrlRawAuthority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlRawFragment.IsSet() {
		localVarFormParams.Add("url.rawFragment", parameterToString(localVarOptionals.UrlRawFragment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlRawPath.IsSet() {
		localVarFormParams.Add("url.rawPath", parameterToString(localVarOptionals.UrlRawPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlRawQuery.IsSet() {
		localVarFormParams.Add("url.rawQuery", parameterToString(localVarOptionals.UrlRawQuery.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlRawSchemeSpecificPart.IsSet() {
		localVarFormParams.Add("url.rawSchemeSpecificPart", parameterToString(localVarOptionals.UrlRawSchemeSpecificPart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlRawUserInfo.IsSet() {
		localVarFormParams.Add("url.rawUserInfo", parameterToString(localVarOptionals.UrlRawUserInfo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlScheme.IsSet() {
		localVarFormParams.Add("url.scheme", parameterToString(localVarOptionals.UrlScheme.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlSchemeSpecificPart.IsSet() {
		localVarFormParams.Add("url.schemeSpecificPart", parameterToString(localVarOptionals.UrlSchemeSpecificPart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlUserInfo.IsSet() {
		localVarFormParams.Add("url.userInfo", parameterToString(localVarOptionals.UrlUserInfo.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Resume management of an entire application
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application


*/
func (a *ManagedControllerApiService) ResumeApplicationUsingDELETE(ctx context.Context, application string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Resume management of a resource
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param resourceId resourceId


*/
func (a *ManagedControllerApiService) ResumeResourceUsingDELETE(ctx context.Context, resourceId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/resources/{resourceId}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceId"+"}", fmt.Sprintf("%v", resourceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Retry a verification
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param environment environment
 * @param payload payload
 * @param verificationId verificationId


*/
func (a *ManagedControllerApiService) RetryVerificationUsingPOST(ctx context.Context, application string, environment string, payload RetryVerificationRequest, verificationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/{application}/environment/{environment}/verifications/retry"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment"+"}", fmt.Sprintf("%v", environment), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verificationId"+"}", fmt.Sprintf("%v", verificationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &payload
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Ad-hoc validate and diff a config manifest
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *ManagedControllerApiService) SchemaUsingGET(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/delivery-configs/schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Update the status of an environment constraint
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param environment environment
 * @param status status


*/
func (a *ManagedControllerApiService) UpdateConstraintStatusUsingPOST(ctx context.Context, application string, environment string, status ConstraintStatus) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/environment/{environment}/constraint"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment"+"}", fmt.Sprintf("%v", environment), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &status
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Create or update a delivery config manifest
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param manifest manifest

@return DeliveryConfig
*/
func (a *ManagedControllerApiService) UpsertManifestUsingPOST(ctx context.Context, manifest DeliveryConfig) (DeliveryConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeliveryConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/delivery-configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &manifest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DeliveryConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Validate a delivery config manifest
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param manifest manifest

@return interface{}
*/
func (a *ManagedControllerApiService) ValidateManifestUsingPOST(ctx context.Context, manifest DeliveryConfig) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/delivery-configs/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &manifest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ManagedControllerApiService Veto an artifact version in an environment
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
 * @param veto veto


*/
func (a *ManagedControllerApiService) VetoUsingPOST(ctx context.Context, application string, veto EnvironmentArtifactVeto) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/managed/application/{application}/veto"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", fmt.Sprintf("%v", application), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &veto
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
